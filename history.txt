1、接收查询指令：根据日期、虚元号查询数值
2、SD容错：出错时重新初始化



！检查全部ei(),在中断内调用的，应全部改为“恢复中断状态”。
如：SericalReadPort()。防止在未退出中断时，再进入中断。

2、西湖文化广场站案例：写入过程可能失败。
措施：a、写入后均读出校验；失败时，应重写，并记录日志。
	  b、应检查写入硬件线路，检查波形、毛刺及最佳速率。
	  c、写入时，关闭中断使能，写入完成后，恢复中断状态。
	  d、电压偏低时，不记录。记录日志事件。

3、重启时，应检查电压，确保100%正常后，才启动存储器读写。


************检查ReadBelt偶尔不响应要点：
1、是否是中断优先级问题。触发后，是否存在RXIF？是否存在反常的IPL？
2、是否已收到足够数据，但校验错误？


=========================================================================
1\Serial_setup  //OK.Serial_setup调用了InitUxrt1();InitUxrt1();中的功能启动可以去掉
2\COM?RX_IE,COM?TX_IE OK
3\查找itoa,btoa,ltoa等
4\查找isWDTWU()，isPOR(),StatusReset()
5\Now() OK
6。PPT



1\修改所有与ms_click related code.
2\IsRxOver();
3\ptr2 ?

检查全部TX_EN=0？

*缩短USB数据读取的时间
1、测量USB HOST响应时间；联系解决高速模式时最后字节丢失的问题。
2、全部存储单元输出，可分为缓冲（快速）、全部（慢速）2类。
2、BAUDRATE从 57600 -> 115200;
3、WRITEFILE长度由 2048 -> 4096;
4、取消字节对拆，采用二进制模式。

一、实测：
1、发送2046字节（1Page）耗时360ms;
2、响应从发送开始500ms，送发送结束140ms;即Host处理时间约140ms;
3、发送30k,耗时约17s;
二、取消字节对拆，采用二进制模式后，发送30k,耗时约11s;
三、WRITEFILE长度由 2048 -> 4096；耗时约10s,不明显；
四、BAUDRATE从 57600 -> 115200;一点效果也没有！？

========================================================================
2009.9.19  
1、	修正了LCD显示时，尾部没有发0（结束标记）的错误。
2、	由于在按钮按下时开背光，0xB501可能混入显示内容中。
	取消中断中的LightOn指令，在Cuesor定位前缴入状态判断。

2009.9.23
1、 修改键盘处理程序（包括中断内部）。调整了blind时间。

2009.11.26
1、spi.c中
void cd(void)		
{
	CS_CFG=1; CS_MEM=1; CS_XME=1; 
}
lFCS_CFG=1o效
void cd(void)		
{
	CS_CFG_DIR=OUT;	CS_CFG=1; Nop();
	CS_MEM_DIR=OUT;	CS_MEM=1; Nop();
	CS_XME_DIR=OUT;	CS_XME=1; Nop();
}
加入Nop();指令;

2009.11.30
UART1 数据发送不对
UART2 配置成相同的引脚数据发送正确
方法：UART1 在数据发送后需要延时几个毫秒；

2010.1.2
RAIN_IE 在初始化的时候没有打开，所以INT2没有进入
RAIN_IF 会在BUZZ打开的时候有机会被置1；INT2中断口的电平没有变化；

2010.3.31
增加R4571中，LVT的状态判断，出错时复位。

2010.10.4
SerialSensor.c added.
RWSerialSensor()中避免使用中断，防止中断嵌套；
修改IsStrInStream(),等待时间由固定方式，改为在收到字符后最多等待1s.
2010.12.1
增加RING引脚输入

2010.12.20
1、增加串口上电等；
2、增加基元C0开关控制，可根据基元开关决定是否Readbelt；

2011.2.12
1、修改RestoreBytes()，使之支持符号数（如温度）。
2、查询传感器指令带时间，在最小时间间隔均广播。
广播时如果数据还没有准备好，可返回ERR_2,或采用前一时刻数据代替。

2011.5.17
1.IsStrInStream(),原来收到1个字符后，等待时间缩短为最多1s.
（北斗卫星的成功回复分2段，前段较快，后段较慢，优化后调整为3s)
2.薄膜开关错误，FUN1、FUN2定义对换（header.h）。

2011.6.3
1.SectorErase()超时，被Watchdog复位。

2011.6.21
1.短信远程设置采用1拆2算法，弃用压缩算法。

2011.6.24
1、修正了键盘显示错误。

2011.7.4
1、增加#include <math.h>,用fabsf()代替abs()。

2011.7.15
1、EncodeCo[]={"Slope co. {%b.ddd~1.000}         "};
=》EncodeCo[]={"Slope co. {%d.ddd~1.000}         "};
使气象风向应用中，最大系数可大于1；
包括Save&Load

2011.8.5
1、修改LevelCoder()时序，增加延时。使长线时，水位数据出错情况消除。

2011.8.6
1、PW_NOFF在Readbelts()不再频繁开关。只开关1次；
   Readbelts()在背光开启状态（认为人工介入），为使运行流畅，不关闭PW_NOFF。
   LevelCoder()不再关闭电源。
   统一在Sleep前再关闭PW_NOFF。
2、SerialSensor()优化，收到完整响应就退出（原：接收至少3s）；
   短间隔循环发送‘A’至多3次，确认‘R’马上退出（原：接收至少3s）
   提高了屏幕显示速度；

2011.8.7
1、LCD显示效果改善。增加fLcdReady变量，lcd_stable()在需要的时候才运行。
   Wakeup后，LCD不再是必须的。人工开启采运行lcd_stable();
   其他需要LCD显示时，先判断fLcdReady,如未稳定，运行lcd_stable();
2、ScheduleReport()移至Wakeup()后，为后续减少Readbelts()调用次数做准备；
   Calendar中，Readbelts()后，记录循环大约耗时300-400ms;
3、修正了ERR1不记录错误。
	offset->*offset 
	in BYTE C0_BeltLen(BYTE *offset,BYTE Cellxs).

2011.8.11
1、修改ReadBelt().在时间(秒)相同时，使用Belt缓冲区数据。
可避免定时记录和定时通信同时发生时，重复ReadBelt。

2011.8.13(未完成)
1、显示History时，一屏显示全部可查询数据；
2、只显示连续数据；

已知错误：
1、传感器中断时，中断标志始终未被清零；（2012.5.10已完成）
2、当前值belt有时会出错；（常规配置）
3、手动发送第一次错误；


2012.4.9
1、支持多个基元轮询；（原各个基元指令一样）

2012.5.10
1、在GPRS发送之前增加，清除传感器发送请求位。
2、修正了当端口数设置错误时，循环不退出的bug。
3、修正了手动检测发送第一次均不成功的bug.
4、修正Belt保存时的bug.	

2013.2.4
1、字节读测试（主元，3个字节）。
错误：写完后有0x18AA误写入。估计有中断插入的。
2、读全部。
3、写字节。（主元、基元、虚元）
4、分页写。

2013-12-8
1、取消StartSensor(),拟移到主循环，
由计划(如TCTL GGDD #1。定时控制 间隔 #1控制方案)控制。

2014-11-1
连接LCD-3时运行正常，脱机运行不响应。
原因：LVD检测过于严厉，导致关闭。

2015-3-15 LCD混乱
1、LCD上电后，Delay_ms(600),再LCD_init(); 应充分延时；
2、LCD缓冲区数据应初始化为可见字符，否则可能滚屏。